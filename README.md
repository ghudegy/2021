# EtvycAuRLZpb6hhe86x0

우선 대회 치느라 다들 수고 많으셨습니다. 올해에는 출제자들이 구데기컵에 지난 대회만큼 문제에 신경을 쓰지 못해서 문제 수나 난이도 조절이 실패했다고 생각하지만, 주최자인 저로서는 구데기컵을 이어받아 문제에 큰 이상 없이 대회를 성공적으로 치른 데에 의의를 두고 싶습니다.

# 잡설

## 공지 글 해석

[공지 글](https://www.acmicpc.net/board/view/65509)은 다음과 같이 해석할 수 있습니다:

- 먼저 "바로 위 문장은 참입니다."라는 문장에 주목해 봅시다. 이 문장이 참이라면 바로 위 문장이 참입니다.
- 바로 위 문장은 "이상의 내용 중 하나 이상이 거짓이고 바로 아래 문장 역시 거짓입니다."입니다. 바로 아래 문장을 참으로 가정했으므로 이는 모순입니다.
- 따라서 "바로 위 문장은 참입니다."는 거짓입니다. 그러려면 "이상의 내용 중 하나 이상이 거짓이고 바로 아래 문장 역시 거짓입니다."가 거짓이어야 합니다.
- "바로 아래 문장 역시 거짓입니다."는 참입니다. 따라서 "이상의 내용 중 하나 이상은 거짓이다"가 거짓이어야 합니다.
- 즉, "이상의 내용 중 ~" 문장 위로 적힌 문장은 모두 거짓이 아님을 알 수 있습니다. 실제로는 그 문장 위로 적힌 내용은 모두 참이었습니다.
- 그 문장 아래로 적힌 문장은 거짓일 수도 있었습니다. 예를 들어 "예비소집은 4월 1일에 진행됩니다."는 명백한 거짓말이었습니다.

## 대회 이름에 대해

대회 이름은 [`random.org`](https://random.org)에서 랜덤 문자열 생성으로 만든 것입니다. 포스터의 알파벳 순서도, 각 알파벳의 색도 제 마음대로 그냥 넣었습니다. 딱히 어떤 의미도 없습니다.

# 대회 중 있었던 사고에 대해

4월 1일, 대회가 중지되었을 때 **대회 중 제출한 남의 코드를 볼 수 있었던** boj의 버그가 있었습니다. 주최자는 이를 안 즉시 대회 시각을 대회 종료 시점으로 수정하고, 버그가 알려지기 전에 다른 사람의 소스 코드를 읽은 사람의 해당 문제에 대한 소스 코드 전부와 읽힌 소스 코드 전부를 눈으로 검수했습니다.

소스 코드를 읽을 조건은 boj의 기본 조건과 같았기 때문에 (자기가 받은 점수보다 더 낮은 점수의 코드만을 확인할 수 있다) 읽힌 소스 코드가 "맞았습니다!!"인 경우는 해당 소스 코드에 다른 문제의 힌트가 될 수 있는 소스 코드가 있는지를 확인했습니다. 부분 점수 문제의 경우 부분 점수를 더 획득하기 위해 얻을 수 있는 정보가 있는지를 중심으로 검사했습니다.

그 결과 사소한 문제가 있을 수 있으나 대회를 망칠 정도로 이 버그를 악용한 사람은 없는 것으로 판단되어, 대회 중에 따로 공지드리지 않고 에디토리얼을 통해 이러한 버그가 있었음을 공지드립니다. 제보해 주신 분께 감사드립니다.

# А. le français

*personne n'a résolu ce problème durant la compétition.*

« 첫 번째 문제인 만큼 본문을 읽고 잘 이해하면 무리 없이 정답 코드를 작성할 수 있는 문제로 출제하였다. » c'est dit dans la 1ère competition de ghudegy cup. on a essayé à suivre ça.

ces deux phrases sont importantes :

- comptez le nombre des lettres alphabétiques **seulement dans ce texte**.
- si vous avez lu ici, trouvez **le multiple de sept le plus proche** à la réponse expliquée ci-dessus.

voyez « seulement dans ce texte ». la description n'inclut jamais « w », « ë » ou beaucoup plus de lettres bien qu'elles sont alphabétiques. il faut exclure ces lettres.

pour 0, il faut imprimer « zéro ». le « é » doit être avec l'accent aigu. aussi, 1.001 est un multiple de 7. si la bonne réponse ci-dessus est 999, le multiple de 7 le plus proche est 1.001, alors il faut imprimer « mille un ».

en fait, beaucoup de coréens ont imprimé « mille **et** un » au lieu de bon « mille un ». « mille un » est juste 1.001, mais « mille **et** un » se traduit comme « a thousand and one » en anglais, ou comme « 천 개 하고도 하나 더 많은 » en coréen. c'est à dire, ça signifie seulement « très beaucoup », pas le nombre 1.001.

attention à ces choses; vous pouvez facilement recevoir `맞았습니다`.

# Ꭺ. No Description 2

*최초 득점자: koosaga (19분)*

**실패는 성공의 어머니다. 일단 문제에 아무 제출이나 해보자.** 정상적인 실행이 되는 코드는 대개 `틀렸습니다` 를 받게 된다. 이 때 소스 코드를 눌러 보면 코드 위에 "다섯 개의 조각을 모아 문제를 완성하자!" 라는 문구를 확인할 수 있다. 다섯 개의 조각이 채점 결과에 대응될 것을 유추할 수 있으며, 특정 채점 결과를 강제할 수 있는 소스 코드를 제출하면 문제에 대한 정보를 얻을 수 있다. 컴파일 에러, 런타임 에러, 시간 초과, 출력 초과, 메모리 초과를 내는 코드를 만드는 것은 어렵지 않으니 각자 해보도록 하자. 모든 정보를 얻었음에도 문제를 못 풀고 있다면, q가 없음에 주의하자.

# ᗅ. 와 쿼리

*최초 득점자: mirusu400 (56분)*

2번 쿼리에서, 빈 줄을 하나 출력하면 된다.

# ꓮ. 두 천재들의 대결

*최고 득점자: ahgus89 (1분, 2점)*

시즌 3, 시즌 4는 tvN에서 방영한 <더 지니어스> 시리즈의 시즌 3, 시즌 4를 뜻하며, 장동민과 오현민이 대결한 종목인 "이 게임"은 십이장기다. 규칙은 [이 영상](https://youtu.be/OKY4HL7cMsg)의 앞부분에서 확인할 수 있다. 

채점 데이터가 주어졌기 때문에, 정답을 미리 구해놓고 하드코딩하는 방법으로 문제를 풀 수 있다. 입력 데이터를 첫 줄에 들어오는 정수로 구분할 수 있어 다음과 같은 형태의 코드를 만들면 된다. 

```python
ans = {6: "0+0+++", 32: "(answer for 1.in)", 29: "(answer for 2.in)", 73: "(answer for 3.in)"}
print('\n'.join(ans[int(input())]))
```

하지만 정답을 구하는 게 어렵다. 장기나 바둑, 체스만큼은 아니지만 가능한 게임 상태의 수가 생각보다 많기 때문에 직접 모든 경우를 따져 보는 것은 불가능에 가깝다.

## 정해

십이장기의 원형인 동물장기(Dobutsu shogi)를 설명하고 있는 [Wikipedia 문서](https://en.wikipedia.org/wiki/D%C5%8Dbutsu_sh%C5%8Dgi)를 확인해보면 Theoretical Result의 Reference로 달려 있는 링크를 확인할 수 있다. 코드를 다운로드받아 컴파일한 뒤, makeAllState와 makeWinLose를 실행하면 된다. 하지만 동물장기와 십이장기의 규칙이 완전히 동일하지는 않기 때문에 해당 규칙이 구현되어 있는 코드 부분을 수정한 뒤 실행해야 한다. 상대편 진영에 새로 말을 놓을 수 없다는 규칙을 추가하기 위해서 `dobutsu.h` 의 `nextMovesForBlack()` 함수 내에 있는 한 줄을 수정하면 된다. 프로그램이 메모리를 꽤 많이 사용한다는 점을 유의하자. 도달 가능한 게임 상태의 수는 총 177,941,677개이며, 출제자는 해당 코드를 실행하는 데 총 3.5시간 정도 걸렸다. 

데이터는 문제 본문에서 언급한 장동민과 오현민의 십이장기 대결을 그대로 가져왔다. 프로그램에 바로 적용할 수는 없지만 거의 모든 에디터에 있는 찾아 바꾸기 기능을 이용하면 된다.

## 기타

자신 있다면 직접 구현하여 풀어도 되지만, 추천하지 않는다. 이걸 구현할 시간과 노력 정도면 적절한 퀄리티의 학사 졸업 논문 한 편 정도를 만들 수 있다. 

온라인 상에서 장동민과 오현민의 십이장기 대국을 분석한 글을 많이 볼 수 있지만, 정확하게 분석한 글은 없는 것으로 보인다. (3.in의 마지막 부분에서 장동민은 큰 실수를 했는데, 거기서 오현민의 이기는 수를 지적하는 글도 찾아보기 어려웠다) 출제자는 두 사람의 대국에 대한 정확한 분석을 글로 쓸 의향이 있지만, 글로 쓰기 위해서는 비기는 수들의 반복 패턴이나 형세 판단에 대한 깊은 이해가 필요하기 때문에 열심히 연구를 하고 있다. 관심 있는 분들은 연락 바랍니다.

# Α. 팩토리얼

*최고 득점자: veydpz (1800분, 534203.79점)*

[factorial-editorial.pdf](https://docs.google.com/viewer?url=https://raw.githubusercontent.com/kipa00/EtvycAuRLZpb6hhe86x0/main/factorial-editorial.pdf)

# Ａ. 댓글, 구독, 크리에이터와의 교류

*최초 득점자: alex9801 (151분)*

문제를 로드하면 1/200의 확률로 스타트링크 홈페이지로 리다이렉트된다. 또는 아래의 '도움이 되었나요?' 섹션에서 버튼을 누르면 일정 확률로 스타트링크 홈페이지로 연결된다. 이를 통해 [스타트링크 유튜브 채널](https://www.youtube.com/c/StartlinkIo/videos)과 관련된 것임을 유추할 수 있다.

스타트링크 유튜브에는 '스타트링크 인트로 1~17'이 게시되어 있는데, 예제 출력이 epoch timestamp임을 유추해 영상이 게시된 시각을 출력하면 문제를 해결할 수 있다.


# $A$. 하이퍼 배열 돌리기

*대회 중 득점자가 없습니다.*

1. 나이브하게 해결할 수 있다.
2. 나이브하게 해결할 수 있다.
3. 나이브하게 해결할 수 있다.
4. 나이브하게 해결할 수 있다.
5. 나이브하게 해결할 수 있다.
6. 나이브하게 해결할 수 있다.
7. 나이브하게 해결할 수 있다.
8. 나이브하게 해결할 수 있다.
9. 나이브하게 해결할 수 있다.
10. 나이브하게 해결할 수 있다.
11. 나이브하게 해결할 수 있다.
12. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
13. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
14. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
15. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
16. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
17. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
18. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
19. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
20. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
21. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
22. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
23. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
24. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
25. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
26. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
27. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
28. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
29. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
30. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
31. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
32. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
33. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
34. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
35. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
36. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
37. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
38. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
39. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
40. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
41. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
42. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
43. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
44. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
45. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
46. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
47. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
48. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
49. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
50. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
51. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
52. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
53. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
54. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
55. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
56. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
57. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
58. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
59. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
60. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
61. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
62. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
63. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
64. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
65. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
66. [BOJ 16926](https://www.acmicpc.net/problem/16926)과 동일한 방법으로 해결할 수 있다.
67. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>n</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
68. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>o</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
69. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>p</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
70. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>q</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
71. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>r</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
72. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
73. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
74. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
75. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
76. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>m</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
77. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>o</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
78. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>p</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
79. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>q</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
80. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>r</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
81. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
82. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
83. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
84. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
85. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>n</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
86. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>p</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
87. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>q</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
88. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>r</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
89. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
90. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
91. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
92. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
93. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>o</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
94. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>q</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
95. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>r</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
96. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
97. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
98. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
99. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
100. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>p</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
101. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>r</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
102. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
103. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
104. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
105. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
106. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>q</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
107. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>r</em>축과 <em>s</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
108. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>r</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
109. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>r</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
110. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>r</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
111. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>r</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
112. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>s</em>축과 <em>t</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
113. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>s</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
114. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>s</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
115. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>s</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
116. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>t</em>축과 <em>u</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
117. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>t</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
118. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>t</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
119. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>u</em>축과 <em>v</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
120. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>u</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  
121. 연산을 최대 100,000번까지 실행하게 될 수 있으므로 배열의 크기를 직접 바꾼다면 시간 초과를 받을 수 있다. 실제로 대칭시키는 대신, <em>v</em>축과 <em>w</em>축을 바꾼다고 생각할 수 있으며, 이는 <em>O</em>(1)이다.  


# A. 진짜 최종 구데기컵 1 경품 당첨자

*최고 득점자: veydpz (28분, 1000000007점)*

선택지의 개수를 보면 알 수 있지만, 같은 상 이름 / 경품 이름이 여러 번 쓰일 수 있음에 주의합시다. 문제를 풀기 위해 필요한 정보는 대부분 온라인에 공개되어 있기 때문에, 열심히 정보를 찾아보면 풀 수 있는 문제였습니다.

1. Marathon Edition 우승자
2. Marathon Edition 준우승자 및 ReguIar Edition 준우승자
3. ReguIar Edition 우승자 및 Speedrun Edition 우승자
4. Speedrun Edition 준우승자
5. 이 대회에 참가하지 않은 사람 중 2019년 대회 최고 등수
6. 모든 에디션에서 총점이 160억점에 가장 가까운 사람
7. 홀수와 짝수의 대결 문제의 오류를 발견한 사람
8. 4차 산업 혁명을 기계학습 없이 서브태스크 2까지만 푼 사람 중 추첨
9. 배중률교를 정해가 아닌 방법으로 푼 사람 중 추첨
10. Marathon Edition에서 Nonogram QR을 마지막으로 1점 이상 획득한 사람
11. 연속합 2147483647 첫 0점자
12. Beginning the Hunt 첫 만점자
13. 대회에 참여하였고 A+B (MC)에 제출하지 않은 사람 중 추첨

## 경품 당첨 기준과 당첨자 아이디 매칭하기
- 당첨자 아이디도 13개, 기준도 13개이므로 중복은 없습니다.
- 당첨자 아이디 중 cubelover님은 현재 BOJ 유저가 아닙니다. cubelover님은 BOJ를 탈퇴하면서 제출 기록이 함께 사라졌는데, 현재의 스코어보드와 당첨자 기준이 맞지 않기 때문에 cubelover님이 몇몇 에디션에서 순위권에 들었음을 알 수 있고, 경우를 따져 보면 2번에 해당하는 아이디가 cubelover여야만 모든 것이 맞아떨어집니다. 이렇게 1, 2, 3, 4번에 해당하는 당첨자 아이디를 결정할 수 있습니다.
- 5번에 해당하는 당첨자를 찾기 위해서는 진짜 구데기컵 2018의 스코어보드에 있는 유저들을 1등부터 한 명씩 진짜 최종 구데기컵 2의 스코어보드에서 찾아보면 됩니다.
- 6번에 해당하는 당첨자는 Marathon Edition의 스코어보드를 통해 확인할 수 있습니다.
- 예제는 믿어도 됩니다. 믿을 수 없다면 예제만 잘 출력하는 코드를 제출해 보시면 됩니다. 아무튼 7번에 해당하는 당첨자는 namnamseo님이 맞습니다.
- 추첨이 들어간 8, 9, 13번은 나중에 정합니다.
- 10, 11, 12번에 해당하는 당첨자는 대회의 전체 제출 현황에서 확인할 수 있습니다.
- 여기까지 정하고 나면 남는 아이디는 greimul, dotorya, pichulia뿐입니다. 이 중 배중률교를 푼 사람은 dotorya님뿐이며, 남은 두 사람 중 4차 산업 혁명을 서브태스크 2까지만 푼 사람은 pichulia님입니다. 그러므로 13번에 해당하는 당첨자는 greimul님으로 정해집니다. 모두 축하드립니다!

## 경품 당첨 기준과 상 이름 매칭하기
- 상 이름이 문제 정보와 관련이 있는 경우가 많습니다. 문제 내용을 많이 알면 알수록 빠르게 문제를 풀어낼 수 있습니다.
- 상 이름은 대부분의 경우 직관적으로 주어졌습니다. 별도의 설명이 필요 없는 상들은 간단하게만 짚고 넘어가겠습니다.
- QR 분해 상 = 10번
- QA 상 = 7번
- 결근상 = 5번
- You Need a Minecraft 상 = 13번
- "Ghudegy Cup looks too intense for me" 상 = 12번: looks too intense for me를 검색해보면 Roller Coaster Tycoon이 나옵니다. 문제 내용이 Roller Coaster Tycoon과 관련 있는 Beginning the Hunt에 걸려 있는 경품이었습니다.
- Re: 제로부터 시작하는 다이나믹 프로그래밍 상 = 11번: 제로는 11번 당첨 기준인 0점과 연관 있으며, 연속합 문제는 잘 알려진 다이나믹 프로그래밍 문제입니다.
- UPWF 위원회 특별상 = 8번: 문제 내용에 UPWF 위원회가 나온 4차 산업 혁명 문제에 걸려 있는 경품이었습니다.
- 직관주의자상 = 9번: 직관주의 / 직관 논리에서는 배중률을 부정합니다. 이는 9번 기준과 연관이 깊습니다.
- 남은 상 이름은 대상과 장려상, 남은 경품 당첨 기준은 1~4번과 6번입니다. 직접 제출해 보면서 상 이름을 확인할 수 있습니다. 이 부분에 한해서는 직관을 버리는 것이 좋습니다.

## 경품 당첨 기준과 경품 이름 매칭하기
- 경품 이름도 문제 정보와 관련이 있는 경우가 많습니다. 역시 별도의 설명이 필요 없거나 위에서 언급한 내용으로 충분한 상들은 간단하게 짚고 넘어갑니다.
- (도서) 4차 산업혁명은 없다 = 8번
- 바코드 스캐너 = 10번(이런 것도 팔더군요...)
- Minecraft = 13번
- Roller Coaster Tycoon 2: Triple Thrill Pack = 12번
- 빵 = 11번: 0점이라서...
- 16GB USB = 6번: 160억점이라서 160억 바이트짜리 USB입니다.
- 1, 2, 3, 4, 5, 7, 9번이 남았는데, 대부분 답은 치킨 기프티콘입니다. 여러 번의 제출을 통해 정답을 확인해보시기 바랍니다.
